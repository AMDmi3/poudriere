#!/bin/sh
# DRAGONFLY SPECIFIC DEFINITIONS

delete_jail() {
	test -z ${JAILNAME} && usage
	jail_exists ${JAILNAME} || err 1 "No such jail: ${JAILNAME}"
	jail_runs ${JAILNAME} &&
		err 1 "Unable to delete jail ${JAILNAME}: it is running"
	msg_n "Removing ${JAILNAME} jail..."
	destroyfs ${JAILMNT} jail
	rm -rf ${POUDRIERED}/jails/${JAILNAME} || :
	echo " done"
}

update_version() {
	local release="$1"
	local login_env osversion

	osversion=`awk '/\#define __DragonFly_version/ { print $3 }' ${JAILMNT}/usr/include/sys/param.h`
	login_env=",UNAME_r=${release% *},UNAME_v=DragonFly ${release},OSVERSION=${osversion}"

	sed -i "" -e "s/,UNAME_r.*:/:/ ; s/:\(setenv.*\):/:\1${login_env}:/" ${JAILMNT}/etc/login.conf
	cap_mkdb ${JAILMNT}/etc/login.conf
}

update_jail() {
	# DragonFly expects 1 argument (quick), FreeBSD doesn't
	jail_exists ${JAILNAME} || err 1 "No such jail: ${JAILNAME}"
	jail_runs ${JAILNAME} &&
		err 1 "Unable to update jail ${JAILNAME}: it is running"

	METHOD=$(jget ${JAILNAME} method)
	if [ -z "${METHOD}" -o "${METHOD}" = "-" ]; then
		METHOD="git"
		jset ${JAILNAME} method ${METHOD}
	fi
	msg "Upgrading using ${METHOD}"
	case ${METHOD} in
	git)
		install_from_git ${1}
		;;
	*)
		err 1 "Unsupported method"
		;;
	esac

}

build_and_install_world() {
	[ $# -ne 1 ] && eargs quick
	local JLOGBASE=${POUDRIERE_DATA}/jailbuild/${JAILNAME}
	local factor=${PARALLEL_JOBS}
	local options="-DNO_GAMES -DNOPROFILE -DNO_BINUTILS221"
	local directive
	mkdir -p ${JLOGBASE}

	export TARGET_ARCH=${ARCH}
	export __MAKE_CONF=/dev/null
	export DESTDIR=${JAILMNT}

	if [ ${1} -eq 1 ]; then
	   directive=quickworld
	else
	   directive=buildworld
	fi
	msg "${JAILNAME}: making ${directive} with ${factor} jobs"
	make -C ${JAILMNT}/usr/src -j${factor} ${options} ${directive} > \
	  ${JLOGBASE}/build.log 2>&1 || err 1 "Fail to ${directive}"

	msg "${JAILNAME}: making installworld"
	make -C ${JAILMNT}/usr/src ${options} installworld > \
	  ${JLOGBASE}/install.log 2>&1 || err 1 "Fail to install world"

	msg "${JAILNAME}: making distribution"
	make -C ${JAILMNT}/usr/src/etc distribution > \
	  ${JLOGBASE}/distrib.log 2>&1 || err 1 "Fail to make distribution"

	# make upgrade required to link device drives (e.g. </dev/video/...)
	msg "${JAILNAME}: making world upgrade"
	make -C ${JAILMNT}/usr/src upgrade > \
	  ${JLOGBASE}/upgrade.log 2>&1 || err 1 "Fail to make world upgrade"

	# make sure world can be dismounted
	cd /
}

convert_property_version () {
	local GREPPAT='^[0-9]\.[0-9]+$'
	local FILTER=`echo "${1}" | grep -E "${GREPPAT}"`
	if [ -n "${FILTER}" ]; then
	   echo RELEASE-${1}
	else
	   echo master
	fi
}

convert_version () {
	# $1 can be empty; "master" will be returned
	local GREPPAT='^[0-9]\.[0-9]+$'
	local FILTER=`echo "${1}" | grep -E "${GREPPAT}"`
	if [ -n "${FILTER}" ]; then
	   echo DragonFly_RELEASE_`echo ${FILTER} | sed 's|\.|_|'`
	else
	   echo master
	fi
}

install_from_git() {
	[ $# -ne 1 ] && eargs quick
	local UPDATE=0
	local proto
	local bver
	local bverz
	local bhack

	[ -d ${JAILMNT}/usr/src ] && UPDATE=1
	mkdir -p ${JAILMNT}/usr/src
	mkdir -p ${JAILMNT}/dev
	cd ${JAILMNT}/usr/src
	if [ ${UPDATE} -eq 0 ]; then
		msg "Checking out the sources via git..."
		bver=$(convert_version ${VERSION})
		git init
		git remote add origin ${DFLY_GIT_URL}
		git fetch --depth=1 origin
		git branch ${bver} origin/${bver}
		git checkout ${bver}
		git pull || err 1 "Fail "
		echo " done"
	else
		msg "Updating the sources via git..."
		if [ -n "${TORELEASE}" ]; then
			bver=$(convert_version "${TORELEASE}")
			bverz=$(convert_property_version "${TORELEASE}")
			BAE=`git branch -l | grep ${bver}`
			if [ -z "${BAE}" ]; then
				git branch ${bver} origin/${bver}
			fi
			git checkout ${bver}
			jset ${JAILNAME} version ${bverz}
		fi
		git pull || err 1 "Fail "
		echo " done"
	fi
	mount -t devfs devfs ${JAILMNT}/dev
	build_and_install_world ${1}
	umount ${JAILMNT}/dev
	bhack="$(date '+%Y-%m-%d/%H:%M')"
	jset ${JAILNAME} timestamp "${bhack}"
}

create_jail() {
	jail_exists ${JAILNAME} && err 2 "The jail ${JAILNAME} already exists"

	[ -z ${VERSION} ] && VERSION=master
	[ -z ${JAILMNT} ] && JAILMNT=${BASEFS}/jails/${JAILNAME}
	[ -z ${JAILFS} ] && JAILFS=${BASEFS}/worlds/${JAILNAME}

	case ${METHOD} in
	git)
		GIT=`which git`
		test -z ${GIT} && \
		  err 1 "You need git on your host to use this method"
		FCT="install_from_git 0"
		;;
	*)
		err 2 "Unknown method to create the jail"
		;;
	esac

	local bverz=$(convert_property_version "${VERSION}")
	createfs ${JAILNAME} ${JAILMNT} ${JAILFS:-none}
	[ -n "${JAILFS}" -a "${JAILFS}" != "none" ] && jset ${JAILNAME} fs ${JAILFS}
	jset ${JAILNAME} version ${bverz}
	jset ${JAILNAME} arch ${ARCH}
	jset ${JAILNAME} mnt ${JAILMNT}

	# Wrap the jail creation in a special cleanup hook that will remove the jail
	# if any error is encountered
	CLEANUP_HOOK=cleanup_new_jail
	jset ${JAILNAME} method ${METHOD}
	${FCT}

	eval `grep -E "^(RELEASE|BRANCH|REVISION)=" ${JAILMNT}/usr/src/sys/conf/newvers.sh `
	jset ${JAILNAME} version ${bverz}
	update_version ${RELEASE}

	pwd_mkdb -d ${JAILMNT}/etc/ -p ${JAILMNT}/etc/master.passwd

	cat > ${JAILMNT}/etc/make.conf << EOF
USE_PACKAGE_DEPENDS=yes
BATCH=yes
WRKDIRPREFIX=/wrkdirs
NO_BACKUP=yes
EOF
	# At least one daemon has to run otherwise jail will exits immediately
	# Let cron run over syslogd (remove "cron_enable=NO")
	cat > ${JAILMNT}/etc/rc.conf << EOF
sendmail_enable=NONE
syslogd_enable=NO
update_motd=NO
EOF
	echo "# dummy" 	            > ${JAILMNT}/etc/fstab
	echo "src"                  > ${JAILMNT}/usr/.cpignore
	echo "local"               >> ${JAILMNT}/usr/.cpignore
	echo "sys"                 >> ${JAILMNT}/.cpignore

	mkdir -p ${JAILMNT}/usr/ports
	mkdir -p ${JAILMNT}/wrkdirs
	mkdir -p ${POUDRIERE_DATA}/logs

	markfs clean ${JAILMNT}
	unset CLEANUP_HOOK
	msg "Jail ${JAILNAME} ${VERSION} ${ARCH} is ready to be used"
}
